"use strict";(globalThis.webpackChunk_indeepvision_idvision_docs=globalThis.webpackChunk_indeepvision_idvision_docs||[]).push([[2319],{2247:(e,t,a)=>{a.d(t,{xA:()=>d,yg:()=>g});var r=a(4041);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},s=Object.keys(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),p=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(a),m=n,g=c["".concat(l,".").concat(m)]||c[m]||u[m]||s;return a?r.createElement(g,i(i({ref:t},d),{},{components:a})):r.createElement(g,i({ref:t},d))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:n,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3367:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var r=a(9575),n=(a(4041),a(2247));const s={sidebar_position:1},i="Estandaritzaci\xf3",o={unversionedId:"software/cpp/testing/estandaritzacio",id:"software/cpp/testing/estandaritzacio",title:"Estandaritzaci\xf3",description:"Organitzaci\xf3 modular",source:"@site/docs/software/cpp/testing/estandaritzacio.md",sourceDirName:"software/cpp/testing",slug:"/software/cpp/testing/estandaritzacio",permalink:"/dev/docs/software/cpp/testing/estandaritzacio",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"cpp",previous:{title:"Arxius de test",permalink:"/dev/docs/software/cpp/testing/arxius-test"},next:{title:"Template",permalink:"/dev/docs/software/cpp/testing/template"}},l={},p=[{value:"Organitzaci\xf3 modular",id:"organitzaci\xf3-modular",level:2},{value:"Descripcions dels <code>SUBCASE</code>",id:"descripcions-dels-subcase",level:2},{value:"Tests round-trip",id:"tests-round-trip",level:2},{value:"Patr\xf3 AAA (Arrange, Act, Assert)",id:"patr\xf3-aaa-arrange-act-assert",level:2}],d={toc:p},c="wrapper";function u({components:e,...t}){return(0,n.yg)(c,(0,r.A)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"estandaritzaci\xf3"},"Estandaritzaci\xf3"),(0,n.yg)("h2",{id:"organitzaci\xf3-modular"},"Organitzaci\xf3 modular"),(0,n.yg)("p",null,"Els tests s'han d'organitzar de manera modular, mantenint la mateixa estructura que la implementaci\xf3 mitjan\xe7ant l'\xfas de ",(0,n.yg)("inlineCode",{parentName:"p"},"TEST_SUITE"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"TEST_CASE")," i ",(0,n.yg)("inlineCode",{parentName:"p"},"SUBCASE"),". Per a cada m\xe8tode s'han de definir diferents ",(0,n.yg)("inlineCode",{parentName:"p"},"SUBCASE")," que simulin totes les situacions possibles."),(0,n.yg)("p",null,"Aquestes situacions s'han d'organitzar en els apartats seg\xfcents:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"ERROR"),": Casos en qu\xe8 les variables d'entrada provoquen que el m\xe8tode falli. En el cas dels tests de la implementaci\xf3, aqu\xed no es valida que les variables d'entrada compleixen els criteris que es fixen a la interf\xedcie p\xfablica. Aix\xf2 es fa en els tests de la capa p\xfablica."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"EDGE"),": Condicions en qu\xe8 les variables d'entrada prenen valors l\xedmit que poden donar lloc a comportaments indefinits. Aquests comportaments s'han de preveure i controlar."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"BASIC"),": Validaci\xf3 que el m\xe8tode funciona correctament amb valors d'entrada esperats i torna els valors esperats."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"COMPLEX"),": Situacions m\xe9s complexes que requereixen dades externes addicionals. Aqu\xed s'inclouen els tests de regressi\xf3, corresponents a errors detectats pr\xe8viament amb dades conegudes, que es volen reproduir i verificar que ja han estat resolts. Tamb\xe9 es poden afegir tests de performance on es valida que el temps d'execuci\xf3 dels m\xe8todes est\xe0 per sota d'uns llindars.")),(0,n.yg)("h2",{id:"descripcions-dels-subcase"},"Descripcions dels ",(0,n.yg)("inlineCode",{parentName:"h2"},"SUBCASE")),(0,n.yg)("p",null,"Les descripcions dels ",(0,n.yg)("inlineCode",{parentName:"p"},"SUBCASE")," han de ser clares i concretes. Han de seguir l'estructura:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"[Verb d'acci\xf3] + [entrada/escenari] + [resultat esperat]\n")),(0,n.yg)("p",null,"Exemple per ",(0,n.yg)("inlineCode",{parentName:"p"},"compare_ordered_point_lists_()"),":"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'SUBCASE("Throws for null pointer in first list") { ... }\nSUBCASE("Throws for mismatched list sizes") { ... }\nSUBCASE("Compares identical ordered lists with 0 differences") { ... }\nSUBCASE("Compares differently ordered lists with differences") { ... }\n')),(0,n.yg)("h2",{id:"tests-round-trip"},"Tests round-trip"),(0,n.yg)("p",null,"Quan tinguem parelles de m\xe8todes que fan accions contr\xe0ries/complement\xe0ries (",(0,n.yg)("inlineCode",{parentName:"p"},"load"),"/",(0,n.yg)("inlineCode",{parentName:"p"},"save"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"get"),"/",(0,n.yg)("inlineCode",{parentName:"p"},"set"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"from"),"/",(0,n.yg)("inlineCode",{parentName:"p"},"to"),"), els tests de round-trip s'han de posar amb els ",(0,n.yg)("inlineCode",{parentName:"p"},"SUBCASE")," del m\xe8tode que faci l'acci\xf3 de guardar (",(0,n.yg)("inlineCode",{parentName:"p"},"save"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"set"),", ",(0,n.yg)("inlineCode",{parentName:"p"},"to"),")."),(0,n.yg)("h2",{id:"patr\xf3-aaa-arrange-act-assert"},"Patr\xf3 AAA (Arrange, Act, Assert)"),(0,n.yg)("p",null,"Els tests han de seguir el patr\xf3 AAA. Aquests tres apartats han d'estar clarament separats mitjan\xe7ant salts de l\xednia."),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"ARRANGE"),": Preparaci\xf3 de les dades que es passaran al m\xe8tode que es vol testar. Aqu\xed es defineixen les condicions d'entrada."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"ACT"),": Crida al m\xe8tode en q\xfcesti\xf3. Nom\xe9s es permet una \xfanica crida per test. En aquesta part tamb\xe9 s'inicialitzen les variables que s'utilitzen per guardar valors de sortida dels m\xe8todes."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("strong",{parentName:"li"},"ASSERT"),": Comprovaci\xf3 de les dades de sortida per validar que el m\xe8tode es comporta segons el que s'espera.")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'SUBCASE("Compares identical ordered lists with 0 differences")\n{\n    // Arrange\n    std::vector<Point2d> list_a = { {0, 0}, {1, 1}, {2, 2} };\n    std::vector<Point2d> list_b = { {0, 0}, {1, 1}, {2, 2} };\n\n    // Act\n    auto result = compare_ordered_point_lists_(list_a, list_b);\n\n    // Assert\n    CHECK(result.num_differences == 0);\n}\n')),(0,n.yg)("admonition",{type:"note"},(0,n.yg)("p",{parentName:"admonition"},"No cal posar els comentaris Arrange, Act i Assert, que separen els blocs. Aqu\xed s'ha fet nom\xe9s per indicar.")))}u.isMDXComponent=!0}}]);